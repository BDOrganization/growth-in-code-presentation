<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>The Evolution of the Devil's Snare</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/moon.css">

        <!-- Custom CSS used to tweak theme -->
        <link rel="stylesheet" href="css/custom.css">

        <!-- Theme used for syntax highlighting of code; try switching to zenburn.css if comments don't show well -->
        <link rel="stylesheet" href="lib/css/monokai-sublime.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>The Evolution of the Devil's Snare</h1>
                    <p>
                        <small>Created by Dustin Singleton and Brandon Rockhold</small>
                    </p>
                </section>
                <section>
                    <h2>Why this presentation?</h2>
                    <img src="images/devils-snare.gif" />
                    <ul>
                        <li>Poor APIs can strangle productivity</li>
                        <li>Many intelligent engineers don't always think in terms of APIs</li>
                        <li>Daily design decisions have long-reaching impacts</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li></li>
                            <li></li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <h2>Why Should You Consider Listening to Us?</h2>
                    <ul>
                        <li>Software Architects with a combined tenure of 15+ years</li>
                        <li>
                            Designed/Reviewed/Refactored A LOT of code for a rapidly growing organization
                            <ul>
                                <li>...and experienced the pain associated with such rapid growth</li>
                            </ul>
                        </li>
                        <li>Passionate about clean code, API design, and being good code citizens in general</li>
                    </ul>
                </section>
                <section>
                    <h2>Overview / Goals</h2>
                    <ul>
                        <li>Discuss API designs which complicate/restrict ability to grow your code base</li>
                        <li>Provide passive transition paths for some* of these scenarios</li>
                        <li>Provide ACTIONABLE information that can be utilized IMMEDIATELY following the presentation</li>
                    </ul>
                    <br />
                    <br />
                    <small>* Only <em>some</em> of these scenarios, as we are unfortunately not wizards</small>
                </section>
                <section>
                    <section data-background-color="#4d7e65">
                        <h2>Poor Data Types / Data Type Abuse</h2>
                        <img src="images/overly-obsessed-girlfriend-loves-your-strings.png" height=259 width=350 />
                    </section>
                    <section>
                        <h2>Poor Data Types / Data Type Abuse</h2>
                        <ul>
                            <li>Easy to misuse / Difficult to understand without additional doc</li>
                            <li>Lack proper means of validation, or at least complicate it</li>
                            <li>Place unnecessary burden on consumers (if they must parse or translate)</li>
                        </ul>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Poor Data Type Example</h2>
                        <pre>
                            <code data-trim>
public interface RecurringAppointment {
    /**
     * @return a string representing the days of the week. For the day of the week that
     *         the recurrence is on, an 'X' character will be present. For days of the
     *         week that there is no recurrence, a space character will be present.
     * 
     *         Ex: " XXXXX " (Monday - Friday) 
     *         
     *         Ex: " X X XX" (Mon/Wed/Fri/Sat)
     */
    String getWeeklyRecurrence();
}
                            </code>
                        </pre>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Consuming Poor Data Type Example</h2>
                        <pre>
                            <code data-trim>
public void consume(RecurringAppointment recurringAppointment) {
    String recurrence = recurringAppointment.getWeeklyRecurrence();
    for (int i = 0; i < recurrence.length(); i++) {
        if (recurrence.charAt(i) != 'X') {
            continue;
        }
        switch (i) {
            case 0:
                System.out.println("ASSUME SUNDAY");
                break;
            case 1:
                System.out.println("ASSUME MONDAY");
                break;
            ...
        }
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>The doc didn't indicate if case-sensitive, so cross your fingers!</li>
                                <li>Awkward zero-based indexing used for parsing days of week; Relies on API doc to indicate that it starts with Sunday vs Monday</li>
                            </ul>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Good Data Type Example</h2>
                        <pre>
                            <code data-trim>
public enum DayOfWeek {
    SUNDAY,
    MONDAY,
    ...
}

public interface RecurringAppointment {
    /**
     * @return the days of the week for which this appointment occurs.
     */
    Set&lt;DayOfWeek&gt; getWeeklyRecurrence();
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Consuming Good Data Type Example</h2>
                        <pre>
                            <code data-trim>
public void consume(RecurringAppointment recurringAppointment) {
    for (DayOfWeek dayOfWeek : recurringAppointment.getWeeklyRecurrence()) {
        switch (dayOfWeek) {
            case SUNDAY:
                System.out.println("DEFINITELY SUNDAY");
                break;
            case MONDAY:
                System.out.println("DEFINITELY MONDAY");
                break;
            ...
        }
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Transition Example (Deprecation)</h2>
                        <pre>
                            <code data-trim>
@Deprecated
public String getWeeklyRecurrence() {
    return recurrence;
}

public Set&lt;DayOfWeek&gt; getWeeklyRecurrenceAsSet() {
    Set&lt;DayOfWeek&gt; daysOfWeekToReturn = new HashSet&lt;DayOfWeek&gt;();
    for (int i = 0; i < recurrence.length(); i++) {
        // logic to check char for non 'X' here...
        switch (i) {
            case 0:
                daysOfWeekToReturn.add(SUNDAY);
                break;
            ...
        }
    }
    return daysOfWeekToReturn;
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>The example shown here is a non-passive change, however, as it replaces the getWeeklyRecurrence method's return type with a Set of DayOfWeek enum values</li>
                                <li>One passive transition option would be to add new API, such as 'getWeeklyRecurrenceAsSet' and have the implementation handle the messy details of translating the existing poor data type to the new good data type.</li>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Transition Example (Wrapper)</h2>
                        <pre>
                            <code data-trim>
public class RecurringAppointmentWrapper {
    private final RecurringAppointment recurringAppointment;

    public RecurringAppointmentWrapper(RecurringAppointment recurringAppointment) {
        this.recurringAppointment = recurringAppointment;
    }

    public long getAppointmentId() {
        // Would have to proxy each method exposed by RecurringAppointment...
        return recurringAppointment.getAppointmentId();
    }

    public Set&lt;DayOfWeek&gt; getWeeklyRecurrence() {
        ...
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <p>Benefits...</p>
                            <ul>
                                <li>Another passive transition would be to wrap the existing RecurringAppointment class with a new class that provides the desired API.</li>
                                <li>Results in less confusion and likely less defects once in use over the original class.</li>
                                <li>When functionality to replace is large, we may not have time to completely refactor. This approach provides consumers with a good API without creating even more debt to pay off in the future.</li>
                            </ul>
                            <p>Downsides...</p>
                            <ul>
                                <li>Each method necessary from the original class will have to be proxied through the wrapper.</li>
                                <li>If other APIs require usage of the original RecurringAppointment class, we'd have to expose API to get an instance of it from the wrapper.</li>
                                <li>Naming for these classes can be hard/awkward, as the best name may have already been taken by the original class.</li>
                            </ul>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Transition Example (Utility)</h2>
                        <pre>
                            <code data-trim>
public class DayOfWeekTranslator {
    public Set&lt;DayOfWeek&gt; translateDaysOfWeek(String daysOfWeek) {
        Set&lt;DayOfWeek&gt; weeklyRecurrence = new HashSet&lt;DayOfWeek&gt;();
        for (int i = 0; i < daysOfWeek.length(); i++) {
            if (daysOfWeek.charAt(i) != 'X') {
                continue;
            }

            weeklyRecurrence.add(translateDayOfWeek(i));
        }
        return weeklyRecurrence;
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <p>Benefits...</p>
                            <ul>
                                <li>Passive approach...</li>
                                <li>Abstracts away messy/error-prone work to interact with bad data type.</li>
                                <li>With multiple consumers, no need for each to recreate this logic.</li>
                                <li>Example abstracts away the switch/case logic to translateDayOfWeek method.</li>
                            </ul>
                            <p>Downsides...</p>
                            <ul>
                                <li>Usage of utility can't be enforced.</li>
                                <li>Consumers may not even know of its existance.</li>
                                <li>Usage of poor data type still exist within code base.</li>
                            </ul>
                        </aside>
                    </section>
                </section>
                <section>
                    <section data-background-color="#4d7e65">
                        <h2>Easily Misused Collections API's</h2>
                        <img src="images/most-interesting-man-hates-his-consumers.png" height=350 width=279 />
                    </section>
                    <section>
                        <h2>Easily Misused Collections API's</h2>
                        <ul>
                            <li>DON'T return NULL collections</li>
                            <li>Growth in API consumption leads to LOTS of avoidable null checks</li>
                            <li>Someone absolutely WILL forget a null check somewhere</li>
                            <li>Iteration over returned collections is primary use-case; be nice to your consumers</li>
                            <li>ABSOLUTELY document how the API behaves, even if you are evil</li>
                        </ul>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Evil Collections API Example</h2>
                        <pre>
                            <code data-trim data-noescape>
public class AppointmentManager {
    /**
     * Returns a collection of the available {@link Date}s that an appointment could
     * begin based on the date provided. If no appointment begin times can be found,
     * <mark>{@code null}</mark> will be returned.
     * 
     * @param startTime
     *            The first possible start date. This value will be used to determine
     *            the available begin dates.
     * @return a list of the available appointment begin dates.
     */
    public Collection&lt;Date&gt; getAvailableBeginTimes(Date startDate, Date endTime) {
        // logic!
    }
}
                            </code>
                        </pre>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Consuming Evil Collections API Example</h2>
                        <pre>
                            <code data-trim data-noescape>
Collection&lt;Date&gt; dates = appointmentManager.getAvailableBeginTimes(new Date(), 
                pastDate);
<mark>if (dates != null)</mark> {
    for (Date date : dates) {
        System.out.println("Available time for appointment: " + date);
    }
}
                            </code>
                        </pre>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Good Collections API Example</h2>
                        <pre>
                            <code data-trim data-noescape>
public class AppointmentManager {
    /**
     * Returns a collection of the available {@link Date}s that an appointment could
     * begin based on the date provided. If no appointment begin times can be found,
     * <mark>an empty collection</mark> will be returned.
     * 
     * @param startTime
     *            The first possible start date. This value will be used to determine
     *            the available begin dates.
     * @return a list of the available appointment begin dates.
     */
    public Collection&lt;Date&gt; getAvailableBeginTimes(Date startDate, Date endTime) {
        // logic!
    }
}
                            </code>
                        </pre>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Consuming Good Collections API Example</h2>
                        <pre>
                            <code data-trim data-noescape>
for (Date date : appointmentManager.getAvailableBeginTimes(new Date(), pastDate)) {
    System.out.println("Available time for appointment: " + date);
}
                            </code>
                        </pre>
                    </section>
                </section>

                <section>
                    <section data-background-color="#4d7e65">
                        <h2>Inconsistent State</h2>
                        <img src="images/not-sure-fry-not-sure-about-immutability.png" height=263 width=350 />
                    </section>

                    <section>
                        <h2>Reasoning About Inconsistent State</h2>
                        <ul>
                            <li>Will the data be validated the same for setter and constructor?</li>
                            <li>Can the data change after construction (is it mutable)?</li>
                            <ul>
                                <li>Collections and dates tend to unintentionally expose mutability</li>
                            </ul>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>These two tend to go together (though they are different concepts).  We will mostly talk about them together.</li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <h2>Stopping Inconsistent State</h2>
                        <ul>
                            <li>Be clear in documenting possible field states</li>
                            <ul>
                                <li>Can this field be null?</li>
                                <li>Can this collection be empty or null?</li>
                            </ul>
                            <li>Enforce state consistently</li>
                            <li>Do not force consumers to handle impossible scenarios</li>
                            <li>Prefer immutability when possible</li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>Enforce state consistently</li>
                                <ul>
                                    <li>Do not enforce non-null values in setter, but allow them in the constructor</li>
                                    <li>Allow consumers to confidently reason about the contract</li>
                                </ul>
                                <li>Do not force consumers to handle impossible scenarios</li>
                                <ul>
                                    <li>if an appointment's descritpion can't be null, don't make a consumer figure out how to handle that</li>
                                </ul>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Inconsistent State Example</h2>
                        <pre>
                            <code data-trim>
public interface Appointment {
    long getId();
    void setId(long id);

    String getDescription();
    void setDescription(String description);

    List&lt;Participant&gt; getParticipants();
    void setParticipants(List&lt;Participant&gt; participants);
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>All getters have a corresponding setter</li>
                                <li>State can change on this object at any time, meaning we can never trust the state</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Consuming Inconsistent State</h2>
                        <pre>
                            <code data-trim>
if (appointment.getDescription() != null) {
    System.out.println("Appointment Description Length: ");
    System.out.println(appointment.getDescription().length());
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>Still not safe, this can throw a NullPointerException</li>
                                <li>Multiple threads could cause the null check to pass but the description to be null</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Consistent State Example</h2>
                        <pre>
                            <code data-trim data-noescape>
public interface Appointment {
    // Omitted javadoc
    long getId();

    /**
     * @return the description for the appointment. This value will <mark>never</mark>
     *         <mark>be {@code null}.</mark>
     */
    String getDescription();

    /**
     * @return all of the participants in the appointment. This list of participants 
     *         could be empty but will <mark>never be {@code null}.</mark> Modifying the returned 
     *         list will not change the internal state of this class.
     */
    List&lt;Participant&gt; getParticipants();
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>Ensures that the values can never be null</li>
                                <li>Ensures that the values can never be changed after construction</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Consistent State Implementation Example</h2>
                        <pre>
                            <code data-trim data-noescape>
public DefaultAppointment(long id, String description,
        List&lt;Participant&gt; participants) {
    this.id = id;

    throwIllegalArgumentExceptionIfNull(description);
    this.description = description;
    this.participants = participants == null ? new ArrayList&lt;Participant&gt;(0)
            : new ArrayList&lt;Participant&gt;(participants);
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>No more setters removes most ways of adding inconsistent state</li>
                                <li>We need to ensure the contructor adheres to the requirement too</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Consistent State Consumer</h2>
                        <pre>
                            <code data-trim data-noescape>
public void consume(Appointment appointment) {
    System.out.println("Appointment Description Length: ");
    System.out.println(appointment.getDescription().length());
}
                            </code>

                            <code data-trim data-noescape>
public void consumeParticipants(Appointment appointment) {
    for (Participant participant : appointment.getParticipants()) {
        System.out.println("Participant: " + participant.getName());
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>No more need for null checking, the description and participants can NEVER be null</li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <h2>Constructor Downfalls</h2>
                        <ul>
                            <li>Growth in model objects makes constructors difficult to use</li>
                            <ul>
                                <li>Ordering of the fields is not intuitive</li>
                                <li>Permutations of the fields causes an explosion in constructor count (telescoping)</li>
                            </ul>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>ordering of the fields is not intuitive</li>
                                <ul>
                                    <li>Was it appointment id first or participant id?</li>
                                </ul>
                                <li>Permutations of the fields causes an explosion in constructor count</li>
                                <ul>
                                    <li>This is no different than a method with many fields (which we will cover in an upcoming section)</li>
                                </ul>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <h2>Builders Can Help</h2>
                        <ul>
                            <li>Able to enforce consistency before construction (in the build method)</li>
                            <li>Parameters are associated to a method with the name (instead of a parameter order)</li>
                            <li>Builders support all possible permutations of the specified fields</li>
                        </ul>
                        <aside class="notes">
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Builder API</h2>
                        <pre>
                            <code data-trim data-noescape>
public interface Builder {
    Builder id(long id);
    Builder description(String description);
    Builder participants(List<Participant> participants);
    Appointment build();
}
                            </code>
                            <code data-trim data-noescape>
public interface Appointment {
    long getId();
    String getDescription();
    List<Participant> getParticipants();
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>All "mutator" methods return the builder, allowing (but not requiring) chained calls</li>
                                <li>The builder is mutable, but the returned Appointment object can not be modified</li>
                                <li>mutator methods match the getter methods (but omit the "get")
                            </ul>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Builder Consumer Example</h2>
                        <pre>
                            <code data-trim data-noescape>
Appointment appointment = new Appointment.Builder().description("appointment 1")
                                                   .id(2).build();
                            </code>
                            <code data-trim data-noescape>
Builder builder = new Appointment.Builder();
builder.description("appointment 1");
builder.id(2);
Appointment appointment = builder.build();
                            </code>
                        </pre>
                        <aside class="notes">
                        </aside>
                    </section>

                </section>

                <section>
                    <section data-background-color="#4d7e65">
                        <h2>Weak Typing</h2>
                        <img src="images/y-u-no-strong-type.png" height=257 width=350 />
                    </section>
                    <section>
                        <h2>Weak Typing</h2>
                        <ul>
                            <li>
                                Unnecessarily exposes consumers to a range of potential defects
                                <ul>
                                    <li>Invalid values around boundaries (for primitives)</li>
                                    <li>Unintentional use of value in API (same type, but different meaning)</li>
                                </ul>
                            </li>
                            <li>Any values which make it through boundary checking, but represent different data will blow up at runtime (or silently wreck havoc)</li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>Error-prone, easier for consumers to mess up</li>
                                <li>Burden to do boundary checking either lies within implementation (and must be doc'd thoroughly), or must be handled by all consumers (and still must be doc'd thoroughly)
                                <li>If correct primitive value type is provided, but it corresponds to a different data element, it may or may not blow up at runtime.</li>
                                <li>Even if it doesn't blow up at runtime, it will cause major issues with data integrity</li>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Weak Type Example</h2>
                        <pre>
                            <code data-trim data-noescape>
public class Appointment {
    ...
    public Appointment(long id, List&lt;Participant&gt; participants) {...}

    public long getId() {
        return id;
    }

    public List&lt;Participant&gt; getParticipants() {
        return participants;
    }
}
public interface ParticipantScheduleManager {
    ParticipantSchedule getParticipantSchedule(long participantId);
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>Here we have a simple Appointment class, which can be constructed with and allows returning a long id.</li>
                                <li>This class also has capability to get a list of Participant objects, each of which also has a long id.</li>
                                <li>The bottom interface is used to retrieve a schedule for the specified Participant, using the long id for the Participant.</li>
                            </ul>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Consuming Weak Type Example</h2>
                        <pre>
                            <code data-trim>
public void consume(Appointment appointment) {
    for (Participant participant : appointment.getParticipants()) {
        System.out
                .println("Getting schedule for participant: " + participant.getId());

        // Oops! You can see here that the wrong long ID was used
        System.out.println(participantScheduleManager
                .getParticipantSchedule(appointment.getId()));
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>In this consumption example, the method is iterating over the various Participant objects involved in the appointment.</li>
                                <li>The participant's id is retrieved an utilized within.</li>
                                <li>When calling the method to retrieve the Participant's scheduled, however, rather than passing the long value for the current Participant, a mistake was made and the Appointment's long id value was instead passed.</li>
                                <li>There is no compile, nor runtime indication that there was any problem here.</li>
                            </ul>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Strong Type Example</h2>
                        <pre>
                            <code data-trim>
public class Appointment {
    ...
    public Appointment(AppointmentIdentifier id, List&lt;Participant&gt; participants) {...}

    public AppointmentIdentifier getId() {
        return id;
    }

    public List&lt;Participant&gt; getParticipants() {
        return participants;
    }
}
public interface ParticipantScheduleManager {
    ParticipantSchedule getParticipantSchedule(ParticipantIdentifier participantId);
    ParticipantSchedule getParticipantSchedule(Participant participant);
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>This example shows updated Appointment and ParticipantScheduleManager APIs to use strong types.</li>
                                <li>The previously used long values are replaced with objects representing the identifiers.</li>
                            </ul>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Consuming Strong Type Example</h2>
                        <pre>
                            <code data-trim>
public void consume(Appointment appointment) {
    for (Participant participant : appointment.getParticipants()) {
        System.out
                .println("Getting schedule for participant: " + participant.getId());

        // The below call to participant.getId() now returns ParticipantIdentifier, so
        // it's no longer possible to accidentally pass the id for the appointment.
        System.out.println(participantScheduleManager
                .getParticipantSchedule(participant.getId()));
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>In the updated consumption example, the previously possible class of defects around using the Appointment's identifier when attempting to retrieve the Participant's schedule is no longer possible.</li>
                                <li>In this case, such a mistake would be a compile-time notification.</li>
                            </ul>
                        </aside>
                    </section>
                </section>
                <section>

                    <section data-background-color="#4d7e65">
                        <h2>Lack of Encapsulation</h2>
                        <img src="images/ancient-aliens-used-encapsulation.png" height=304 width=350 />
                    </section>

                    <section>
                        <h2>Lack of Encapsulation</h2>
                        <ul>
                            <li>Makes it difficult to re-use concepts</li>
                            <li>New implementations of concepts can never be passively introduced</li>
                            <li>Causes explosion in methods, fields, and test data</li>
                        </ul>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Code With No Encapsulation</h2>
                        <pre>
                            <code data-trim>
public class Appointment
{
    private long appointmentId;
    private String description;
    private long organizerId;
    private String organizerName;
    private long roomId;
    private String roomDescription;
    private boolean doesRoomHaveProjector;
    private Date beginTime;
    private Date endTime;
    private Set&lt;DayOfWeek&gt; weeklyRecurrence;
    private Set&lt;MonthOfYear&gt; monthlyRecurrence;

    // getters and setters (because there is too many fields for a constructor)
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>
                                    We have many different concepts represented here:
                                    <ul>
                                        <li>Appointment</li>
                                        <li>Organizer</li>
                                        <li>Room</li>
                                        <li>Schedule of the appointment</li>
                                    </ul>
                                </li>
                                <li>It MAY BE true that there may only ever be one room for an Appointment, but that does not mean you should not encapsulate from the start</li>
                                <li>Encapsulation is not just for things that you want to put in a list</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Code With Encapsulation</h2>
                        <pre>
                            <code data-trim>
public class Appointment
{
    private long appointmentId;
    private String description;
    private Organizer organizer;
    private Room room;
    private Schedule schedule;

    // getters and setters (because there is too many fields for a constructor)
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>We have represented the different concepts as objects</li>
                                <li>We have freedom to swap out different scheduling algorithms and never have to touch this class</li>
                                <li>Tests are simplified to only 5 fields now</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Code Study - Class "A"</h2>
                        <ul>
                            <li>Class was first created in 2007 (on that fateful day)</li>
                            <li>Part of a core functionality</li>
                            <li>Attempted no encapsulation (aside from 1 object that already existed)</li>
                            <li>Original author left the team by the time activity in the file increased</li>
                        </ul>
                    </section>

                    <section>
                        <img src="images/class-growth-per-year.png" height=500 width=900 />
                        <aside class="notes">
                            <ul>
                                <li>Data is based off first release of project containing class per year (first release in 2008, 2009, etc)</li>
                                <li>The field count (in green) is how many class fields this object had (mostly private)</li>
                                <li>"Other Method" just indicates those that are not getter or setter</li>
                                <li>The field count started at 29 (large to start with) but since has doubled!</li>

                            </ul>
                        </aside>
                    </section>

                    <section>
                        <img src="images/releases-by-year-for-project-containing-class-a.png" height=500 width=900 />
                        <aside class="notes">
                            <ul>
                                <li>class was first written in 2007, released in 2008</li>
                                <li>5 years of minimal activity</li>
                                <li>exponential growth in project releases containg this class</li>
                                <li>2016 was slower, potentially for a few factors, mostly re-writing and changed releases strategy</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Lessons Learned - Class "A"</h2>
                        <ul>
                            <li>Encapsulate early and often, allows room for growth</li>
                            <li>You never know how others might add to the code you write today, set them up for success</li>
                            <li>Just because an object will only contain one of something, it does not justify avoiding encapsulation</li>
                        </ul>
                    </section>

                </section>

                <section>
                    
                    <section data-background-color="#4d7e65">
                        <h2>Growing Parameter List</h2>
                        <img src="images/the-number-of-params-is-too-damn-high.png" height=263 width=350 />
                    </section>

                    <section>
                        <h2>Growing Parameter List</h2>
                        <ul>
                            <li>Can lead to an explosion of overloaded methods (in the interest of passivity)</li>
                            <li>
                                Difficult/Painful to consume
                                <ul>
                                    <li>Increased liklihood of errors due to specifying params in incorrect order</li>
                                    <li>Hard to remember what each value represents, particularly if not strongly typed</li>
                                    <li>Hard to find correct version of method to call for each use-case</li>
                                </ul>
                            </li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>When param lists include several occurrences of the same types, it is incredibly easy to specify the values out of order.</li>
                                <li>ASK THE AUDIENCE to raise hands if they've ever been in that situation...</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Poor Handling of Growing Params</h2>
                        <p>Initial release of API</p>
                        <pre>
                            <code data-trim>
public interface AppointmentManager {
    List&lt;Appointment&gt; getAppointments(long appointmentId);
}
                            </code>
                        </pre>
                        <p>Follow-up release of API</p>
                        <pre>
                            <code data-trim>
public interface AppointmentManager {
    List&lt;Appointment&gt; getAppointments(long appointmentId);

    List&lt;Appointment&gt; getAppointments(long appointmentId, long participantId,
            Date beginDate, Date endDate);
}
                            </code>
                        </pre>
                        <p>...and the cycle continues through the years</p>
                        <aside class="notes">
                            <ul>
                                <li>Upon initial release, the API may have started out simple, with perhaps a single parameter...</li>
                                <li>Over time, the list of parameters may begin to increase. To remain passive, we overload the API and create various combinations of those parameters.</li>
                                <li>This cycle can continue until things get ridiculous if not addressed in a different manner, however.</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Introduce Parameter Object</h2>
                        <p>An object in which closely related parameters are encapsulated together. More info <a href="http://refactoring.com/catalog/introduceParameterObject.html" target="_blank">here</a>.</p>
                        <pre>
                            <code data-trim>
public class AppointmentRetrievalCriteria {
    private final long appointmentId;
    private final long participantId;
    private final Date beginDate;
    private final Date endDate;

    public AppointmentRetrievalCriteria(Builder builder) {...}
    public long getAppointmentId() {...}
    public long getParticipantId() {...}
    public Date getBeginDate() {...}
    public Date getEndDate() {...}

    public static class Builder {
        ...
        public AppointmentRetrievalCriteria build() {...}
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>This example shows a new AppointmentRetrievalCriteria object which represents a collection of related parameters used for retrieving appointments.</li>
                                <li>Rather than continue to either make non-passive changes or to overload the methods in the AppointmentManager API we were just looking at, this approach allows us to introduce one last API change that should grow more gracefully over time.</li>
                                <li>If you were to deprecate the existing API's and update their implementations to use this method internally, you have a completely passive change for any consumer which is not writing their own implementation of your interface.</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Consume Parameter Object (All Values)</h2>
                        <pre>
                            <code data-trim>
public void consumeAndSpecifyAllValues() {
    AppointmentRetrievalCriteria.Builder builder = 
            new AppointmentRetrievalCriteria.Builder();
 
    // Could instead chain these builder methods...
    builder.appointmentId(1L);
    builder.participantId(2L);
    builder.beginDate(new Date(1000L));
    builder.endDate(new Date(2000L));

    appointmentManager.getAppointments(builder.build());
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>This example utilizes the Builder pattern that we previously talked about and specifies all values.</li>
                                <li>Note that you could also chain these method calls, as is typical with builders.</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Consume Parameter Object (Required Values)</h2>
                        <pre>
                            <code data-trim>
public void consumeAndSpecifyRequiredValues() {
    AppointmentRetrievalCriteria.Builder builder = 
            new AppointmentRetrievalCriteria.Builder();
    builder.appointmentId(1L);
    builder.beginDate(new Date(1000L));

    appointmentManager.getAppointments(builder.build());
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>One of the major benefits with refactoring to utilize a parameter object is that you are now free to add non-required fields in a passive manner.</li>
                                <li>ONLY in cases where a new required field is introduced (and which CANNOT have a default value provided on behalf of the consumer) are there non-passive changes.</li>
                            </ul>
                        </aside>
                    </section>

                </section>

                <section>

                    <section data-background-color="#4d7e65">
                        <h2>Restrictive Collections API's</h2>
                        <img src="images/scumbag-steve-restricts-your-collections.png" height=350 width=349 />
                    </section>

                    <section>
                        <h2>Restrictive Collections API's</h2>
                        <ul>
                            <li>
                                Can be burdensome for consumers
                                <ul>
                                    <li>They may write code to convert from one type to another</li>
                                    <li>As growth occurs, so too would amount of translation code</li>
                                </ul>
                            </li>
                            <li>May result in pre-emptive decisions around whether or not iteration order or duplicate elements matter</li>
                        </ul>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Restrictive API Example</h2>
                        <pre>
                            <code data-trim>
public interface AppointmentManager {
    // Assumes order is needed, but what if you're just iterating over elements?
    List&lt;Appointment&gt; createAppointments(List&lt;AppointmentCriteria&gt; criteria);
}
                            </code>
                        </pre>
                        <p>Not necessarily overly restrictive, but it may be. At least think about it on a case-by-case basis.</p>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Consuming Restrictive API Example</h2>
                        <pre>
                            <code data-trim data-noescape>
public class Consumer {
    private final AppointmentManager appointmentManager;
    public Consumer(AppointmentManager appointmentManager) {
        this.appointmentManager = appointmentManager;
    }

    public void consume() {
        List&lt;AppointmentCriteria&gt; appointmentCriteria = 
                new ArrayList&lt;AppointmentCriteria&gt;();
        appointmentManager.createAppointments(appointmentCriteria);

        Set&lt;AppointmentCriteria&gt; appointmentCriteriaSet = 
                new HashSet&lt;AppointmentCriteria&gt;();
        // <mark>DOES NOT COMPILE</mark>
        appointmentManager.createAppointments(appointmentCriteriaSet);
    }
}
                            </code>
                        </pre>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Nonrestrictive API Example (Passive)</h2>
                        <ul>
                            <li>Less-restrictive param and SAME return type</li>
                            <li>Assumes order/duplicates for param is irrelevant</li>
                        </ul>
                        <pre>
                            <code data-trim>
public interface AppointmentManager {
    List&lt;Appointment&gt; createAppointments(
            Collection&lt;AppointmentCriteria&gt; criteria);
}
                            </code>
                        </pre>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Nonrestrictive API Example (Non-passive)</h2>
                        <ul>
                            <li>
                                Less-restrictive param and DIFFERENT return type
                                <ul>
                                    <li>Non-passive; requires creating List from returned Collection for previous consumers</li>
                                </ul>
                            </li>
                            <li>Assumes order/duplicates for param AND return values is irrelevant</li>
                        </ul>
                        <pre>
                            <code data-trim>
public interface AppointmentManager {
    Collection&lt;Appointment&gt; createAppointments(
            Collection&lt;AppointmentCriteria&gt; criteria);
}
                            </code>
                        </pre>
                    </section>

                </section>

                <section>
                    <section data-background-color="#4d7e65">
                        <h2>Unnecessarily Restrictive Validation</h2>
                        // TODO Include img src and dimensions as appropriate
                        <img src="" height=350 width=350 />
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>
                    <section>
                        <h2>Unnecessarily Restrictive Validation</h2>
                        <ul>
                            <li>...</li>
                            <li>...</li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Code Example Slide</h2>
                        <pre>
                            <code data-trim>
// code goes here with no additional spaces
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>
                </section>
                <section>
                    <section data-background-color="#4d7e65">
                        <h2>Abstraction Leaks</h2>
                        <img src="images/first-world-leaked-abstraction-problems.png" height=233 width=350 />
                    </section>
                    <section>
                        <h2>Abstraction Leaks</h2>
                        <ul>
                            <li>
                                Complicates future migration efforts to new technology/implementation
                                <ul>
                                    <li>Likely requires painful non-passive API changes</li>
                                    <li>May prevent uplifting to new technology necessary to support growth</li>
                                    <li>May make existing API's awkward/confusing if not replaced</li>
                                </ul>
                            </li>
                            <li>May reveal avenues for attackers to exploit</li>
                            <li>Can unnecessarily complicate consumer understanding (if level of detail is inappropriate)</li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Common Extraction Leak Examples</h2>
                        <pre>
                            <code data-trim data-noescape>
public interface AppointmentManager {
    AppointmentRemoveStatus removeAppointment(Appointment appointment)
            <mark>throws SQLException</mark>;

    // Note the <mark>Database</mark> reference in the method name...
    AppointmentRemoveStatus removeAppointmentFromDatabase(Appointment appointment);

    /**
     * Removes the appointment from appointments table in the <mark>database</mark> where the
     * {@code appointmentId} matches app_id.
     * 
     * @param appointmentId
     *            The id matching the app_id in the appointments table.
     * @return the status of the removal.
     */
    AppointmentRemoveStatus removeAppointment(long appointmentId);
}
                            </code>
                        </pre>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Common Extraction Leak Examples</h2>
                        <pre>
                            <code data-trim data-noescape>
public interface AppointmentManager {
    // Note the <mark>Button</mark> reference in the method name...
    AppointmentRemoveStatus removeButtonClicked();

    /**
     * Removes the specified appointment.
     * 
     * @param appointment
     *            The appointment to be removed.
     * @return the status of the appointment removal. This will be formatted as a <mark>JSON</mark>
     *         <mark>string</mark> with a property called {@code status} and a value of either
     *         {@code SUCCESS} or {@code FAILURE}.
     */
    String removeSingleAppointment(Appointment appointment);
}
                            </code>
                        </pre>
                    </section>
                    <section>
                        <h2>Common Abstraction Leak Indicators</h2>
                        <ul>
                            <li>Database concepts, table/field references</li>
                            <li>Data formats which are too low-level for the current API</li>
                            <li>
                                UI concepts specific to your current implementation
                                <ul>
                                    <li>UI controls like buttons, checkboxes, hyperlinks, etc</li>
                                    <li>UI frameworks; watch your APIs AND import statements</li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                </section>
                <section>

                    <section data-background-color="#4d7e65">
                        <h2>Compiling Against Implementations</h2>
                        <img src="images/confession-bear-enjoys-compiling-against-implementations.png" height=364 width=350 />
                    </section>

                    <section data-background-image="images/Nonono_cat.gif" data-background-position="top">
                        <aside class="notes">

                        </aside>
                    </section>

                   <section>
                        <h2>Do Not</h2>
                        <ul>
                            <li>Require an implementation of an object in your API</li>
                            <li>Require an interface and then cast to an implementation inside the method (pure evil)</li>
                        </ul>
                    </section>

                   <section>
                        <h2>Too late</h2>
                        <ul>
                            <li>
                                If you are already here, you likely have the following options:
                                <ul>
                                    <li>Promote the method being consumed from the implementation to the interface</li>
                                    <li>Create a new interface containing other interface methods and implemetnation method</li>
                                </ul>
                            </li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>Promote the method - (non passive for other implementors)</li>
                                <li>Create a new interface - (limits scope to only consumers of this API)</li>
                            </ul>
                        </aside>
                    </section>
                </section>

                <section>
                    <section data-background-color="#4d7e65">
                        <h2>Burdening Consumers with Common Tasks</h2>
                        // TODO Include img src and dimensions as appropriate
                        <img src="" height=350 width=350 />
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>

                    <section>
                        <h2>Burdening Consumers with Common Tasks</h2>
                        <ul>
                            <li>There is a "typical" consumption of your API</li>
                            <li>Consider the burden placed on consumers</li>
                            <li>Collections tend to be a common source of extra burden</li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li>Consider the burden placed on consumers - (is there a way to lessen it)?  Perhaps write sample tests consuming it.</li>
                                <li>Collections tend to be a common source of extra burden - (consider wrapping in a "plural" object)</li>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Burdening Consumers Example</h2>
                        <pre>
                            <code data-trim>
public interface Appointment {
    List&lt;Participant&gt; getParticipants();
}
                            </code>
                            <code data-trim>
public interface Participant {
    String getName();
    boolean isBooked();
    boolean isConflicted();
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>Imagine that we only want to get booked participants or conflicted ones?</li>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Burdening Consumers Consumer Example</h2>
                        <pre>
                            <code data-trim>
List&lt;Participant&gt; bookedParticipants = new ArrayList&lt;Participant&gt;();
for (Participant participant : appointment.getParticipants()) {
    if (participant.isBooked()) {
        bookedParticipants.add(participant);
    }
}
                            </code>
                            <code data-trim>
List&lt;Participant&gt; conflictedParticipants = new ArrayList&lt;&gt;(participants.size());
for (Participant singleParticipant : participants) {
    if (singleParticipant.isConflicted()) {
        conflictedParticipants.add(singleParticipant);
    }
}
                            </code> 
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>This is a lot of code considering how simple the use case is (and perhaps how common it is)</li>
                        </aside>
                    </section>

                    <section data-state="slide-with-code">
                        <h2>Burdening Consumers Participants API</h2>
                        <pre>
                            <code data-time>
public interface Appointment {
    Participants getParticipants();
}
                            </code>
                            <code data-trim>
public interface Participants {
    List&lt;Participant&gt; getAllParticipants();
    List&lt;Participant&gt; getAllBookedParticipants();
    List&lt;Participant&gt; getAllConflictedParticipants();
}
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li>
                                    Here we make Appointment return Participants instead of a list.
                                    <ul>
                                        <li>Implementation can change from List to any other data type internally</li>
                                        <li>Consumers code will be much cleaner</li>
                                        <li>Future performance gains can be made consistently across consumers</li>
                                        <li>Consider returning a stream for java 8 programmers</li>
                                    </ul>
                                </li>
                        </aside>
                    </section>

                </section>

                <section>
                    <section data-background-color="#4d7e65">
                        <h2>Lack of Adapters</h2>
                        // TODO Include img src and dimensions as appropriate
                        <img src="" height=350 width=350 />
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>
                    <section>
                        <h2>Lack of Adapters</h2>
                        <ul>
                            <li>...</li>
                            <li>...</li>
                        </ul>
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>
                    <section data-state="slide-with-code">
                        <h2>Code Example Slide</h2>
                        <pre>
                            <code data-trim>
// code goes here with no additional spaces
                            </code>
                        </pre>
                        <aside class="notes">
                            <ul>
                                <li></li>
                                <li></li>
                        </aside>
                    </section>
                </section>
                <section>
                    <h1>Summary</h1>
                    <ul>
                        <li></li>
                        <li></li>
                    </ul>
                </section>
                <section>
                    <h1>Questions?</h1>
                </section>
                <section>
                    <h1>Please Leave Us Feedback</h1>
                    <table>
                        <thead>
                            <th>1</th>
                            <th>2</th>
                            <th>3</th>
                            <th>4</th>
                            <th>5</th>
                        </thead>
                        <tr>
                            <td>Very Poor</td>
                            <td>Poor</td>
                            <td>Fair</td>
                            <td>Good</td>
                            <td>Very Good</td>
                        </tr>
                    </table>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,

                transition: 'convex',

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { 
                        src: 'plugin/highlight/highlight.js', 
                        async: true, 
                        callback: function() {
                            hljs.configure({
                                languages: ['java']
                            });
                            hljs.initHighlightingOnLoad(); 
                        } 
                    }
                ]
            });
        </script>
    </body>
</html>
